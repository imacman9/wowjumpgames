<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Luckiest+Guy&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
        }
        canvas {
            display: block;
        }

        /* --- Main Menu Styles --- */
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 650px;
            padding: 50px 30px 30px 30px;

            background-image: url('https://i.imgur.com/FhRSEjn.png');
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;

            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0,0,0,0.8);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            min-height: 400px;
            box-sizing: border-box;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            color: #E0FFFF;
            opacity: 1;
            visibility: visible;
            background-color: rgba(0, 50, 100, 0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        /* --- Start Button Style (for main game) --- */
        #startButton {
            padding: 18px 40px;
            font-size: 2.2em;
            color: white;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-top: auto;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            z-index: 51;
            margin-bottom: 20px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);

            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 50%, #1A7DEE 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0, 0, 0, 0.4),
                0 0 15px rgba(100, 150, 255, 0.6);
        }

        #startButton:hover {
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 50%, #2A8DEE 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 8px 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(120, 170, 255, 0.8);
        }

        #startButton:active {
            background: linear-gradient(to bottom, #1A7DEE 0%, #3C9AF7 50%, #7DCFFF 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0, 0, 0, 0.5) inset,
                0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* --- Mini-Game Button Style (similar to start button) --- */
        #miniGameButton {
            padding: 15px 35px;
            font-size: 1.8em;
            color: white;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-top: 10px;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            z-index: 51;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);

            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 50%, #1A7DEE 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0, 0, 0, 0.4),
                0 0 15px rgba(100, 180, 255, 0.6);
        }
        #miniGameButton:hover {
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 50%, #2A8DEE 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 8px 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(120, 200, 255, 0.8);
        }
        #miniGameButton:active {
            background: linear-gradient(to bottom, #1A7DEE 0%, #3C9AF7 50%, #7DCFFF 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0, 0, 0, 0.5) inset,
                0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* --- Mobile Controls Menu Button (top-left) --- */
        #mobileControlsMenuButton, #miniGameMobileControlsMenuButton {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            z-index: 51;

            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(to bottom, rgba(125, 200, 255, 0.7) 0%, rgba(60, 120, 255, 0.7) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.5) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 2px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.2s ease-in-out;
        }
        #miniGameMobileControlsMenuButton {
            top: 50px;
            left: 15px;
            display: none;
        }
        #mobileControlsMenuButton:hover, #miniGameMobileControlsMenuButton:hover {
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.8) 0%, rgba(40, 100, 255, 0.8) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.7) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.4);
            transform: translateY(-1px);
        }
        #mobileControlsMenuButton:active, #miniGameMobileControlsMenuButton:active {
            background: linear-gradient(to bottom, rgba(60, 120, 255, 0.7) 0%, rgba(125, 200, 255, 0.7) 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
        }


        #messageBox {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px;
            text-align: center;
            z-index: 100;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to bottom, rgba(0, 70, 140, 0.8) 0%, rgba(0, 30, 80, 0.8) 100%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 15px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 0 25px rgba(0, 100, 200, 0.7);
        }
        #messageBox h2 {
            margin-top: 0;
            font-size: 2.2em;
            color: #4CAF50;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        #messageBox button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: white;
            cursor: pointer;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;

            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.3);
        }
        #messageBox button:hover {
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 5px 15px rgba(0,0,0,0.4);
        }
        #messageBox button:active {
            background: linear-gradient(to bottom, #3C9AF7 0%, #7DCFFF 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- Fullscreen Button Styles --- */
        #fullscreenButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(to bottom, rgba(125, 200, 255, 0.7) 0%, rgba(60, 120, 255, 0.7) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.5) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 2px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.2s ease-in-out;
        }
        #fullscreenButton:hover {
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.8) 0%, rgba(40, 100, 255, 0.8) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.7) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.4);
            transform: translateY(-1px);
        }
        #fullscreenButton:active {
            background: linear-gradient(to bottom, rgba(60, 120, 255, 0.7) 0%, rgba(125, 200, 255, 0.7) 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
        }

        /* --- Mobile Controls (Joystick for 3D Game) --- */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 20;
        }

        /* Joystick Base */
        #joystick-base {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            pointer-events: auto;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.4) 0%, rgba(60, 120, 255, 0.4) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 3px 10px rgba(0,0,0,0.4),
                0 0 15px rgba(100, 180, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        /* Joystick Knob */
        #joystick-knob {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: grab;
            transition: all 0.1s ease;

            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9) 0%, rgba(150, 200, 255, 0.9) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }
        #joystick-knob:active {
            background: linear-gradient(to bottom, rgba(180, 210, 240, 0.9) 0%, rgba(130, 180, 230, 0.9) 100%);
            cursor: grabbing;
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.4);
        }

        /* Jump button */
        #jump-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Luckiest Guy', 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, #00BFFF 0%, #1E90FF 100%);
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0,0,0,0.4),
                0 0 20px rgba(0, 191, 255, 0.7);
        }
        #jump-button:active {
            background: linear-gradient(to bottom, #1E90FF 0%, #00BFFF 100%);
            transform: translateY(1px);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- Main Game Container (holds 3D canvas and its UI) --- */
        #mainGameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            display: flex; /* Use flexbox to center canvas */
            justify-content: center;
            align-items: center;
        }
        #mainGameContainer canvas { /* Style for the Three.js canvas */
            position: relative; /* Changed to relative so flexbox can center it */
            width: 100%;
            height: 100%;
        }

        /* --- 3D Game Timer Display --- */
        #gameTimerDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.8em;
            font-family: 'Luckiest Guy', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }


        /* --- Mini-Game Specific Styles --- */
        #miniGameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column; /* To stack elements vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            z-index: 60;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }

        #miniGameCanvas {
            border: 2px solid white;
            background-color: black;
            /* Adjust margin-top if you want space from score/back button */
            /* margin-top: 10px; */
        }

        #miniGameScore {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            font-family: 'Luckiest Guy', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 61;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 15px;
            border-radius: 8px;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #backToMainMenuButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: white;
            cursor: pointer;
            font-family: 'Luckiest Guy', cursive;
            z-index: 61;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;

            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #DC143C 0%, #8B0000 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.4) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.3);
        }
        #backToMainMenuButton:hover {
            background: linear-gradient(to bottom, #8B0000 0%, #DC143C 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 5px 15px rgba(0,0,0,0.4);
        }
        #backToMainMenuButton:active {
            background: linear-gradient(to bottom, #8B0000 0%, #DC143C 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- NEW: Mini-Game Mobile Controls Styles --- */
        #mini-game-mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 70;
            margin-bottom: 20px;
        }

        #mini-joystick-base {
            position: relative;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            pointer-events: auto;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.4) 0%, rgba(60, 120, 255, 0.4) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 3px 10px rgba(0,0,0,0.4),
                0 0 15px rgba(100, 180, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        #mini-joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: grab;
            transition: all 0.1s ease;

            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9) 0%, rgba(150, 200, 255, 0.9) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }
        #mini-joystick-knob:active {
            background: linear-gradient(to bottom, rgba(180, 210, 240, 0.9) 0%, rgba(130, 180, 230, 0.9) 100%);
            cursor: grabbing;
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.4);
        }

        #mini-jump-button {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: bold;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Luckiest Guy', 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, #4682B4 0%, #6A5ACD 100%);
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0,0,0,0.4),
                0 0 20px rgba(70, 130, 180, 0.7);
        }
        #mini-jump-button:active {
            transform: translateY(1px);
            background: linear-gradient(to bottom, #6A5ACD 0%, #4682B4 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="mainGameContainer">
        <div id="messageBox">
            <h2 id="messageText"></h2>
            <button id="restartButton">Play Again</button>
        </div>
        <div id="fullscreenButton" title="Toggle Fullscreen">
            &#x26F6;
        </div>
        <div id="gameTimerDisplay">Time: 00:00.00</div>
        <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
            <div id="jump-button">JUMP</div>
        </div>
    </div>

    <div id="mainMenu">
        <button id="mobileControlsMenuButton">Show Mobile Controls</button>
        <button id="startButton">Start 3D Game</button>
        <button id="miniGameButton">Play 2D Mini-Game</button>
    </div>

    <div id="miniGameContainer">
        <canvas id="miniGameCanvas"></canvas>
        <div id="miniGameScore">Score: 0</div>
        <button id="backToMainMenuButton">Back to Main Menu</button>
        <div id="mini-game-mobile-controls">
            <div id="mini-joystick-base">
                <div id="mini-joystick-knob"></div>
            </div>
            <div id="mini-jump-button">JUMP</div>
        </div>
        <button id="miniGameMobileControlsMenuButton">Show Mobile Controls</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // === GLOBAL GAME STATE FLAGS ===
        let gameRunning = false;    // True if 3D game is active
        let miniGameActive = false; // True if 2D mini-game is active

        // === GLOBAL REFERENCES FOR MINI-GAME AUDIO (allows stopping from outside its scope) ===
        let miniGameMusicPlayer = null; // Stores the Audio object for mini-game music
        let miniGameSfx = {}; // Will hold jump, gameOver sounds for mini-game

        // === GLOBAL ASSET DEFAULTS (from 3D game) ===
        const DEFAULT_3D_PLAYER_SKIN_URL = 'https://i.imgur.com/cV6r1ty.png';
        const DEFAULT_3D_MUSIC_URL = 'https://ia600900.us.archive.org/26/items/music1_20250625/music1.mp3';

        // --- DOM Elements ---
        const mainMenu = document.getElementById('mainMenu');
        const startButton = document.getElementById('startButton');
        const miniGameButton = document.getElementById('miniGameButton');
        const mainGameContainer = document.getElementById('mainGameContainer');
        const miniGameContainer = document.getElementById('miniGameContainer');
        const backToMainMenuButton = document.getElementById('backToMainMenuButton');
        const mobileControlsMenuButton = document.getElementById('mobileControlsMenuButton');
        const miniGameMobileControlsMenuButton = document.getElementById('miniGameMobileControlsMenuButton');
        const mobileControls = document.getElementById('mobile-controls');
        const miniGameMobileControls = document.getElementById('mini-game-mobile-controls');


        // === Three.js Setup (Main Game) ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Append 3D game canvas to its container
        // Ensure the renderer.domElement is added only once
        if (!mainGameContainer.querySelector('canvas')) {
            mainGameContainer.appendChild(renderer.domElement);
        }

        // === Physics World (Main Game) ===
        if (typeof CANNON === 'undefined') {
            console.error("ERROR: CANNON.js library is not loaded! Physics will not work. Please ensure it's loaded from a working CDN.");
            alert("CANNON.js physics library failed to load. The game's physics will not function. This could be due to network restrictions.");
        } else {
            console.log("CANNON.js library detected. Initializing physics world.");
        }

        const world = new CANNON.World();
        world.gravity.set(0, -20, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 20;
        world.solver.tolerance = 0.001;
        world.defaultContactMaterial.friction = 0.5;
        world.defaultContactMaterial.restitution = 0.1;
        console.log("CANNON.js physics world initialized.");

        // === Lighting (Main Game) ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        scene.add(directionalLight);

        // === Player (Main Game) ===
        const playerSize = 1.5;
        const textureLoader = new THREE.TextureLoader();
        const playerTexture = textureLoader.load(
            DEFAULT_3D_PLAYER_SKIN_URL, // Using global constant here
            undefined,
            undefined,
            (err) => {
                console.error('An error happened loading the player texture.', err);
                playerMesh.material = new THREE.MeshLambertMaterial({ color: 0xff4500 }); // Fallback color
                playerMesh.material.needsUpdate = true;
            }
        );

        const playerGeo = new THREE.PlaneGeometry(playerSize, playerSize);
        const playerMat = new THREE.MeshLambertMaterial({
            map: playerTexture,
            color: 0xffffff,
            transparent: true,
            side: THREE.DoubleSide
        });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // --- Physics Material for Player ---
        const playerPhysicsMaterial = new CANNON.Material("playerMaterial");
        const playerShape = new CANNON.Box(new CANNON.Vec3(playerSize / 2, playerSize / 2, 0.5));
        const playerBody = new CANNON.Body({ mass: 5, shape: playerShape, material: playerPhysicsMaterial });
        playerBody.allowSleep = false;
        playerBody.fixedRotation = true;
        playerBody.linearDamping = 0.1;
        playerBody.angularDamping = 0.9;

        let startPosition = new CANNON.Vec3(0, 5, 0);
        playerBody.position.copy(startPosition);
        world.addBody(playerBody);
        console.log("Player physics body created and added to world. fixedRotation set to true.");

        // === Platforms (Main Game) ===
        let platforms = [];
        const winPlatformMaterial = new CANNON.Material("winPlatformMaterial");
        const regularPlatformMaterial = new CANNON.Material("regularPlatformMaterial");

        // --- COMPLETED PHYSICS MATERIAL DEFINITION (Placeholder, as your code was cut off) ---
        const playerRegularContactMaterial = new CANNON.ContactMaterial(
            playerPhysicsMaterial,
            regularPlatformMaterial,
            {
                friction: 0.8, // Increased friction
                restitution: 0.1 // Slight bounce
            }
        );
        world.addContactMaterial(playerRegularContactMaterial);

        const playerWinContactMaterial = new CANNON.ContactMaterial(
            playerPhysicsMaterial,
            winPlatformMaterial,
            {
                friction: 0.2, // Lower friction for potential slide
                restitution: 0.7 // Bouncy win!
            }
        );
        world.addContactMaterial(playerWinContactMaterial);

        let endPlatformBody = null;

        // Function to create a platform (3D game)
        function createPlatform(x, y, z, width, height, depth, isWinPlatform = false) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color: isWinPlatform ? 0x00ff00 : 0x808080 }); // Green for win, grey for regular
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const body = new CANNON.Body({
                mass: 0, // static
                shape: shape,
                material: isWinPlatform ? winPlatformMaterial : regularPlatformMaterial
            });
            body.position.copy(mesh.position);
            world.addBody(body);

            platforms.push({ mesh, body, isWinPlatform });
            if (isWinPlatform) {
                endPlatformBody = body;
            }
        }

        // === Game State & Controls (Main Game) ===
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;
        let lastJumpTime = 0;
        const jumpCooldown = 500; // ms

        // Mobile Controls Variables
        let joystickActive = false;
        let joystickX = 0;
        let joystickY = 0;
        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');
        const jumpButton = document.getElementById('jump-button');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const gameTimerDisplay = document.getElementById('gameTimerDisplay');
        let gameStartTime;
        let timerInterval;
        let requestId; // To store requestAnimationFrame ID for 3D game

        // Fullscreen toggle
        const fullscreenButton = document.getElementById('fullscreenButton');
        fullscreenButton.addEventListener('click', toggleFullscreen);

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // === Event Listeners (Main Game) ===
        document.addEventListener('keydown', (event) => {
            if (!gameRunning) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) {
                        playerBody.velocity.y = 10;
                        canJump = false; // Prevent immediate re-jump
                        lastJumpTime = Date.now();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (!gameRunning) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    break;
            }
        });

        // Joystick event listeners
        joystickBase.addEventListener('touchstart', handleJoystickStart, { passive: false });
        joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
        joystickBase.addEventListener('touchend', handleJoystickEnd, { passive: false });

        joystickBase.addEventListener('mousedown', handleJoystickStart, { passive: false });
        joystickBase.addEventListener('mousemove', handleJoystickMove, { passive: false });
        joystickBase.addEventListener('mouseup', handleJoystickEnd, { passive: false });
        joystickBase.addEventListener('mouseleave', handleJoystickEnd, { passive: false }); // End if mouse leaves base

        jumpButton.addEventListener('touchstart', handleJumpButton, { passive: false });
        jumpButton.addEventListener('click', handleJumpButton, { passive: false });

        function handleJoystickStart(event) {
            if (!gameRunning) return;
            event.preventDefault(); // Prevent scrolling/zooming
            joystickActive = true;
            updateJoystickPosition(event);
            joystickKnob.style.transition = 'none'; // Disable transition during drag
            joystickBase.style.transition = 'none';
        }

        function handleJoystickMove(event) {
            if (!gameRunning || !joystickActive) return;
            event.preventDefault(); // Prevent scrolling/zooming
            updateJoystickPosition(event);
        }

        function handleJoystickEnd(event) {
            if (!gameRunning) return;
            joystickActive = false;
            joystickX = 0;
            joystickY = 0;
            // Reset knob position
            joystickKnob.style.transform = `translate(-50%, -50%)`;
            joystickKnob.style.transition = 'all 0.1s ease'; // Re-enable transition
            joystickBase.style.transition = 'all 0.2s ease-in-out';
        }

        function updateJoystickPosition(event) {
            const rect = joystickBase.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxRadius = rect.width / 2 - joystickKnob.offsetWidth / 2;

            let deltaX = clientX - centerX;
            let deltaY = clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxRadius) {
                deltaX = (deltaX / distance) * maxRadius;
                deltaY = (deltaY / distance) * maxRadius;
            }

            joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            joystickX = deltaX / maxRadius; // Normalize to -1 to 1
            joystickY = -deltaY / maxRadius; // Normalize and invert Y for typical game controls
        }

        function handleJumpButton(event) {
            if (!gameRunning) return;
            event.preventDefault();
            if (canJump) {
                playerBody.velocity.y = 10;
                canJump = false;
                lastJumpTime = Date.now();
                if (mainGameSfx.jump) playMainGameSound(mainGameSfx.jump); // Play 3D game jump sound
                else console.warn(">>> mainGameSfx.jump missing!");
            }
        }

        // === Game Logic (Main Game) ===
        const cameraOffset = new THREE.Vector3(0, 5, -10); // Offset from player
        let currentAnimationId = null;

        function animateMainGame() {
            if (!gameRunning) {
                cancelAnimationFrame(currentAnimationId);
                currentAnimationId = null;
                return;
            }

            // Update physics world
            world.step(1 / 60);

            // Update player mesh position from physics body
            playerMesh.position.copy(playerBody.position);
            playerMesh.quaternion.copy(playerBody.quaternion);

            // Check if player is on ground for jumping
            const contacts = world.contacts;
            let onGroundThisFrame = false;
            for (let i = 0; i < contacts.length; i++) {
                const contact = contacts[i];
                if ((contact.bi === playerBody && contact.bj.mass === 0) || // player vs static body
                    (contact.bj === playerBody && contact.bi.mass === 0)) { // static body vs player
                    // Check if contact normal is mostly upwards
                    const normal = contact.ni; // normal points from bi to bj
                    const playerIsA = (contact.bi === playerBody);
                    // If player is A, normal points from player (A) to platform (B). We want Y to be positive.
                    // If player is B, normal points from platform (A) to player (B). We want Y to be negative (player below platform).
                    const normalY = playerIsA ? normal.y : -normal.y;

                    if (normalY > 0.7) { // Threshold for considering it "ground"
                        onGroundThisFrame = true;
                    }
                }
            }

            if (onGroundThisFrame) {
                if (!canJump && (Date.now() - lastJumpTime > jumpCooldown)) {
                    canJump = true;
                }
            } else {
                canJump = false;
            }


            // Player Movement (Keyboard & Joystick)
            const impulseStrength = 5; // How strongly the player moves horizontally
            const currentVelocity = playerBody.velocity;
            let targetVX = 0;
            let targetVZ = 0;

            if (moveForward || joystickY > 0.1) targetVZ = -impulseStrength;
            if (moveBackward || joystickY < -0.1) targetVZ = impulseStrength;
            if (moveLeft || joystickX < -0.1) targetVX = -impulseStrength;
            if (moveRight || joystickX > 0.1) targetVX = impulseStrength;

            // Apply impulse for horizontal movement
            // Only apply if the current velocity is less than the target, to prevent infinite acceleration
            if (targetVX !== 0 && Math.abs(currentVelocity.x) < Math.abs(targetVX)) {
                playerBody.applyImpulse(new CANNON.Vec3(targetVX, 0, 0), playerBody.position);
            }
            if (targetVZ !== 0 && Math.abs(currentVelocity.z) < Math.abs(targetVZ)) {
                playerBody.applyImpulse(new CANNON.Vec3(0, 0, targetVZ), playerBody.position);
            }

            // Keep camera centered on player
            camera.position.copy(playerMesh.position).add(cameraOffset);
            camera.lookAt(playerMesh.position);

            // Check for game over (fall off world)
            if (playerMesh.position.y < -10) {
                showGameOverScreen("Game Over! You fell.");
            }

            // Check for win condition (landing on end platform)
            if (endPlatformBody) {
                for (let i = 0; i < contacts.length; i++) {
                    const contact = contacts[i];
                    if ((contact.bi === playerBody && contact.bj === endPlatformBody) ||
                        (contact.bj === playerBody && contact.bi === endPlatformBody)) {
                        showGameOverScreen("You Win! Congratulations!");
                    }
                }
            }

            renderer.render(scene, camera);
            currentAnimationId = requestAnimationFrame(animateMainGame);
        }

        // Timer functions
        function startTimer() {
            gameStartTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 10);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimerDisplay() {
            const elapsedTime = Date.now() - gameStartTime;
            const minutes = Math.floor(elapsedTime / 60000);
            const seconds = Math.floor((elapsedTime % 60000) / 1000);
            const milliseconds = Math.floor((elapsedTime % 1000) / 10);

            gameTimerDisplay.textContent = `Time: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
        }

        function showGameOverScreen(message) {
            if (!gameRunning) return; // Prevent multiple calls
            gameRunning = false;
            stopTimer();
            if (currentAnimationId) {
                cancelAnimationFrame(currentAnimationId);
                currentAnimationId = null;
            }
            if (mainGameMusicPlayer) mainGameMusicPlayer.pause();
            if (mainGameSfx.gameOver) playMainGameSound(mainGameSfx.gameOver);

            messageText.textContent = message;
            messageBox.style.display = 'block';
            mobileControls.style.display = 'none'; // Hide mobile controls
            mobileControlsMenuButton.style.display = 'none'; // Hide toggle button

            // Add an overlay to dim the game behind the message box
            mainGameContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            mainGameContainer.style.backdropFilter = 'blur(5px)';
        }

        restartButton.addEventListener('click', restartMainGame);

        function restartMainGame() {
            console.log("Restarting Main Game...");
            gameRunning = true;
            messageBox.style.display = 'none';
            playerBody.position.copy(startPosition);
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0); // Reset angular velocity too
            canJump = true;
            lastJumpTime = 0;

            // Clear existing platforms and re-initialize
            platforms.forEach(p => {
                scene.remove(p.mesh);
                world.removeBody(p.body);
            });
            platforms = [];
            endPlatformBody = null;
            initializeMainGamePlatforms(); // Re-create platforms

            // Reset game environment visual (remove overlay)
            mainGameContainer.style.backgroundColor = 'initial'; // Or 'transparent'
            mainGameContainer.style.backdropFilter = 'none';

            startTimer();
            animateMainGame();
            if (mainGameMusicPlayer) playMainGameSound(mainGameMusicPlayer);
            gameTimerDisplay.style.display = 'block';

            // Re-show mobile controls if they were active
            if (mobileControlsMenuButton.textContent === 'Hide Mobile Controls') {
                 mobileControls.style.display = 'flex';
            }
            mobileControlsMenuButton.style.display = 'block';
        }

        function initializeMainGamePlatforms() {
            createPlatform(0, 0, 0, 10, 1, 10); // Starting platform
            createPlatform(10, 2, -5, 5, 1, 5);
            createPlatform(20, 4, 0, 7, 1, 7);
            createPlatform(30, 6, 5, 6, 1, 6, true); // Win platform
            console.log("Main game platforms initialized.");
        }

        // --- Main Game Audio Setup ---
        let mainGameSfx = {};
        let mainGameMusicPlayer = new Audio();
        let isMainGameMusicLoaded = false;
        let isMainGameSfxLoaded = false;

        function loadMainGameAudio() {
            try {
                mainGameSfx.jump = new Audio('https://ia801508.us.archive.org/17/items/jump_20250625/jump.mp3');
                mainGameSfx.gameOver = new Audio('https://ia600700.us/13/items/gameover_202507/gameOver.wav');
                
                if (mainGameSfx.jump) mainGameSfx.jump.volume = 0.7;
                if (mainGameSfx.gameOver) mainGameSfx.gameOver.volume = 0.8;
                Object.values(mainGameSfx).forEach(sound => {
                    if (sound) sound.preload = 'auto';
                });
                isMainGameSfxLoaded = true;
                console.log("Main Game SFX loaded.");
            } catch (e) {
                console.error("Main Game SFX Creation Error", e);
                mainGameSfx = {};
            }

            try {
                mainGameMusicPlayer.src = DEFAULT_3D_MUSIC_URL;
                mainGameMusicPlayer.loop = true;
                mainGameMusicPlayer.volume = 0.4;
                mainGameMusicPlayer.preload = 'auto';
                mainGameMusicPlayer.oncanplaythrough = () => {
                    isMainGameMusicLoaded = true;
                    console.log("Main Game Music loaded.");
                };
                mainGameMusicPlayer.onerror = (e) => {
                    console.error("Main Game Music Load Error:", e);
                };
                // musicPlayer.load(); // Call load() to start preloading
            } catch (e) {
                console.error("Main Game Music Player Error:", e);
                mainGameMusicPlayer = null;
            }
        }

        function playMainGameSound(sound) {
            if (!sound || typeof sound.play !== 'function') {
                console.warn(`Invalid sound for main game.`);
                return;
            }
            if (sound !== mainGameMusicPlayer) {
                sound.currentTime = 0;
            }
            const p = sound.play();
            if (p !== undefined) {
                p.catch(e => {
                    console.warn(`Main Game Playback error:`, e);
                });
            }
        }

        // === Mini-Game Script Start ===
        const miniGameCanvas = document.getElementById('miniGameCanvas');
        const miniGameCtx = miniGameCanvas.getContext('2d');
        const miniGameScoreElement = document.getElementById('miniGameScore');

        const MINI_BASE_WIDTH = 480;
        const MINI_BASE_HEIGHT = 320;
        const MINI_TARGET_WIDTH = 1299;
        const MINI_TARGET_HEIGHT = 729;
        const miniScaleFactor = MINI_TARGET_WIDTH / MINI_BASE_WIDTH;
        const miniZoomOutFactor = 0.75;

        miniGameCanvas.width = MINI_TARGET_WIDTH;
        miniGameCanvas.height = MINI_TARGET_HEIGHT;

        // Mini-game image assets
        const miniGameBackgroundImage = new Image();
        let isMiniGameBgLoaded = false;
        miniGameBackgroundImage.onload = () => { isMiniGameBgLoaded = true; console.log(">>> Mini-Game BG Img loaded."); };
        miniGameBackgroundImage.onerror = () => { console.error(">>> FAILED Mini-Game BG Img load!"); };
        miniGameBackgroundImage.src = 'https://i.imgur.com/WIpckDf.jpeg';

        const miniGamePlayerImage = new Image();
        let isMiniGamePlayerImageLoaded = false;
        miniGamePlayerImage.onload = () => { isMiniGamePlayerImageLoaded = true; console.log(">>> Mini-Game Player Img loaded."); };
        miniGamePlayerImage.onerror = () => { console.error(">>> FAILED Mini-Game Player Img load!"); };
        miniGamePlayerImage.src = 'https://i.imgur.com/cV6r1ty.png'; // Using the same player skin URL

        // Mini-game audio assets
        miniGameMusicPlayer = new Audio(); // Re-initialize or use the global variable
        let isMiniGameMusicLoaded = false;
        let isMiniGameSfxLoaded = false;

        function loadMiniGameAudio() {
            try {
                miniGameSfx.jump = new Audio('https://ia801508.us.archive.org/17/items/jump_20250625/jump.mp3');
                miniGameSfx.gameOver = new Audio('https://ia600700.us.archive.org/13/items/gameover_202507/gameOver.wav');

                if (miniGameSfx.jump) miniGameSfx.jump.volume = 0.7;
                if (miniGameSfx.gameOver) miniGameSfx.gameOver.volume = 0.8;
                Object.values(miniGameSfx).forEach(sound => {
                    if (sound) sound.preload = 'auto';
                });
                isMiniGameSfxLoaded = true;
                console.log("Mini-Game SFX loaded.");
            } catch (e) {
                console.error("Mini-Game SFX Creation Error", e);
                miniGameSfx = {};
            }

            try {
                miniGameMusicPlayer.src = 'https://ia600900.us.archive.org/26/items/music1_20250625/music1.mp3'; // Mini-game uses same music as 3D game
                miniGameMusicPlayer.loop = true;
                miniGameMusicPlayer.volume = 0.4;
                miniGameMusicPlayer.preload = 'auto';
                miniGameMusicPlayer.oncanplaythrough = () => {
                    isMiniGameMusicLoaded = true;
                    console.log("Mini-Game Music loaded.");
                };
                miniGameMusicPlayer.onerror = (e) => {
                    console.error("Mini-Game Music Load Error:", e);
                };
            } catch (e) {
                console.error("Mini-Game Music Player Error:", e);
                miniGameMusicPlayer = null;
            }
        }

        function playMiniGameSound(sound) {
            if (!sound || typeof sound.play !== 'function') {
                console.warn(`Invalid sound for mini-game.`);
                return;
            }
            if (sound !== miniGameMusicPlayer) {
                sound.currentTime = 0;
            }
            const p = sound.play();
            if (p !== undefined) {
                p.catch(e => {
                    console.warn(`Mini-Game Playback error:`, e);
                });
            }
        }

        // Mini-game constants & variables
        const miniPlayerWidth = 60 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerHeight = 60 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerGravity = 0.6 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerJumpPower = 14 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerHorizontalAcceleration = 3.5 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerMaxHorizontalSpeed = 9 * miniScaleFactor * miniZoomOutFactor;
        const miniPlayerHorizontalFriction = 0.85;

        const miniPlatformWidth = 80 * miniScaleFactor * miniZoomOutFactor;
        const miniPlatformHeight = 10 * miniScaleFactor * miniZoomOutFactor;
        const miniPlatformScrollSpeed = 1.5 * miniScaleFactor * miniZoomOutFactor;

        let miniPlayer = {};
        let miniPlatforms = [];
        let miniScore = 0;
        let miniGameAnimationFrameId = null;

        const miniInitialPlayerState = {
            x: 50 * miniScaleFactor * miniZoomOutFactor,
            y: 50 * miniScaleFactor * miniZoomOutFactor,
            vy: 0,
            vx: 0,
            onGround: false
        };

        // Mini-game mobile controls state
        let miniJoystickActive = false;
        let miniJoystickX = 0;
        let miniJoystickY = 0;
        const miniJoystickBase = document.getElementById('mini-joystick-base');
        const miniJoystickKnob = document.getElementById('mini-joystick-knob');
        const miniJumpButton = document.getElementById('mini-jump-button');

        // Mini-game input handlers
        function handleMiniGameClick(event) {
            if (!miniGameActive) {
                console.log("Attempting to start mini-game.");
                startMiniGame();
                return;
            }
            // If the click is on the canvas (and not a control button), trigger jump
            const rect = miniGameCanvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Only trigger jump if click is within canvas bounds and not on mobile controls if visible
            const isClickOnControls = miniGameMobileControls.style.display === 'flex' &&
                                      event.target.closest('#mini-game-mobile-controls');

            if (!isClickOnControls && clickX >= 0 && clickX <= rect.width && clickY >= 0 && clickY <= rect.height) {
                miniPlayerJump();
            }
        }
        miniGameCanvas.addEventListener('click', handleMiniGameClick);

        function handleMiniGameScroll(event) {
            if (!miniGameActive) return;
            event.preventDefault(); // Prevent page scrolling

            if (event.deltaY < 0) { // Scroll up
                miniPlayer.vx -= miniPlayerHorizontalAcceleration;
            } else if (event.deltaY > 0) { // Scroll down
                miniPlayer.vx += miniPlayerHorizontalAcceleration;
            }
        }
        miniGameCanvas.addEventListener('wheel', handleMiniGameScroll, { passive: false });

        // Mini-game mobile controls
        miniJoystickBase.addEventListener('touchstart', handleMiniJoystickStart, { passive: false });
        miniJoystickBase.addEventListener('touchmove', handleMiniJoystickMove, { passive: false });
        miniJoystickBase.addEventListener('touchend', handleMiniJoystickEnd, { passive: false });
        miniJoystickBase.addEventListener('mousedown', handleMiniJoystickStart, { passive: false });
        miniJoystickBase.addEventListener('mousemove', handleMiniJoystickMove, { passive: false });
        miniJoystickBase.addEventListener('mouseup', handleMiniJoystickEnd, { passive: false });
        miniJoystickBase.addEventListener('mouseleave', handleMiniJoystickEnd, { passive: false });

        miniJumpButton.addEventListener('touchstart', handleMiniJumpButton, { passive: false });
        miniJumpButton.addEventListener('click', handleMiniJumpButton, { passive: false });

        function handleMiniJoystickStart(event) {
            if (!miniGameActive) return;
            event.preventDefault();
            miniJoystickActive = true;
            updateMiniJoystickPosition(event);
            miniJoystickKnob.style.transition = 'none';
            miniJoystickBase.style.transition = 'none';
        }

        function handleMiniJoystickMove(event) {
            if (!miniGameActive || !miniJoystickActive) return;
            event.preventDefault();
            updateMiniJoystickPosition(event);
        }

        function handleMiniJoystickEnd(event) {
            if (!miniGameActive) return;
            miniJoystickActive = false;
            miniJoystickX = 0;
            miniJoystickY = 0;
            miniJoystickKnob.style.transform = `translate(-50%, -50%)`;
            miniJoystickKnob.style.transition = 'all 0.1s ease';
            miniJoystickBase.style.transition = 'all 0.2s ease-in-out';
            miniPlayer.vx = 0; // Stop horizontal movement when joystick released
        }

        function updateMiniJoystickPosition(event) {
            const rect = miniJoystickBase.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxRadius = rect.width / 2 - miniJoystickKnob.offsetWidth / 2;

            let deltaX = clientX - centerX;
            let deltaY = clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxRadius) {
                deltaX = (deltaX / distance) * maxRadius;
                deltaY = (deltaY / distance) * maxRadius;
            }

            miniJoystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            miniJoystickX = deltaX / maxRadius; // Normalize to -1 to 1
            miniJoystickY = -deltaY / maxRadius; // Normalize and invert Y for typical game controls (up is positive)

            // Apply horizontal force based on joystickX
            if (miniJoystickX > 0.1) {
                miniPlayer.vx += miniPlayerHorizontalAcceleration;
            } else if (miniJoystickX < -0.1) {
                miniPlayer.vx -= miniPlayerHorizontalAcceleration;
            } else {
                miniPlayer.vx *= miniPlayerHorizontalFriction; // Apply friction if joystick is centered
            }
        }

        function handleMiniJumpButton(event) {
            if (!miniGameActive) return;
            event.preventDefault();
            miniPlayerJump();
        }

        // Mini-game drawing
        function drawMiniGameBackground() {
            if (isMiniGameBgLoaded && miniGameBackgroundImage.complete && miniGameBackgroundImage.naturalHeight !== 0) {
                miniGameCtx.drawImage(miniGameBackgroundImage, 0, 0, miniGameCanvas.width, miniGameCanvas.height);
            } else {
                miniGameCtx.fillStyle = '#87CEEB';
                miniGameCtx.fillRect(0, 0, miniGameCanvas.width, miniGameCanvas.height);
            }
        }

        function drawMiniGamePlayer() {
            if (!miniPlayer || typeof miniPlayer.x !== 'number') return;
            if (isMiniGamePlayerImageLoaded && miniGamePlayerImage.complete && miniGamePlayerImage.naturalHeight !== 0) {
                miniGameCtx.drawImage(miniGamePlayerImage, miniPlayer.x, miniPlayer.y, miniPlayerWidth, miniPlayerHeight);
            } else {
                miniGameCtx.fillStyle = 'red';
                miniGameCtx.fillRect(miniPlayer.x, miniPlayer.y, miniPlayerWidth, miniPlayerHeight);
            }
        }

        function drawMiniGamePlatforms() {
            miniGameCtx.fillStyle = 'green';
            miniPlatforms.forEach(p => {
                miniGameCtx.fillRect(p.x, p.y, p.width, p.height);
            });
        }

        // Mini-game game logic
        function updateMiniGamePlayer() {
            if (!miniGameActive) return;

            miniPlayer.onGround = false;

            // Apply friction if no joystick input
            if (Math.abs(miniJoystickX) < 0.1) {
                miniPlayer.vx *= miniPlayerHorizontalFriction;
            }

            miniPlayer.x += miniPlayer.vx;

            if (Math.abs(miniPlayer.vx) > miniPlayerMaxHorizontalSpeed) {
                miniPlayer.vx = Math.sign(miniPlayer.vx) * miniPlayerMaxHorizontalSpeed;
            }

            if (miniPlayer.x < 0) {
                miniPlayer.x = 0;
                miniPlayer.vx = 0;
            }
            if (miniPlayer.x + miniPlayerWidth > miniGameCanvas.width) {
                miniPlayer.x = miniGameCanvas.width - miniPlayerWidth;
                miniPlayer.vx = 0;
            }

            miniPlayer.vy += miniPlayerGravity;
            miniPlayer.y += miniPlayer.vy;
        }

        function miniPlayerJump() {
            if (miniGameActive && miniPlayer.onGround) {
                miniPlayer.vy = -miniPlayerJumpPower;
                miniPlayer.onGround = false;
                if (miniGameSfx.jump) playMiniGameSound(miniGameSfx.jump);
                else console.warn(">>> miniGameSfx.jump missing!");
            }
        }

        function initializeMiniGamePlatforms() {
            miniPlatforms = [];
            miniPlatforms.push({
                x: 0,
                y: miniGameCanvas.height - (30 * miniScaleFactor * miniZoomOutFactor),
                width: miniGameCanvas.width * 1.5,
                height: miniPlatformHeight
            });
            let c = miniPlatforms[0].x + miniPlatforms[0].width * 0.7;
            for (let i = 1; i < 8; i++) c = addMiniGamePlatform(c);
        }

        function addMiniGamePlatform(minX) {
            let nX = minX + (Math.random() * 100 + 70) * miniScaleFactor * miniZoomOutFactor,
                nY = miniGameCanvas.height - (50 * miniScaleFactor * miniZoomOutFactor) - (Math.random() * 140 * miniScaleFactor * miniZoomOutFactor);
            if (nY < 50 * miniScaleFactor * miniZoomOutFactor) nY = 50 * miniScaleFactor * miniZoomOutFactor;
            let nW = miniPlatformWidth + (Math.random() * 40 * miniScaleFactor * miniZoomOutFactor);
            miniPlatforms.push({
                x: nX,
                y: nY,
                width: nW,
                height: miniPlatformHeight
            });
            return nX + nW;
        }

        function updateMiniGamePlatforms() {
            if (!miniGameActive) return;
            let r = 0;
            for (let i = miniPlatforms.length - 1; i >= 0; i--) {
                const p = miniPlatforms[i];
                p.x -= miniPlatformScrollSpeed;
                if (p.x + p.width < 0) {
                    miniPlatforms.splice(i, 1);
                    miniScore += 10;
                } else {
                    if (p.x + p.width > r) r = p.x + p.width;
                }
            }
            while (r < miniGameCanvas.width + miniPlatformWidth * 2) r = addMiniGamePlatform(r);
        }

        function checkMiniGameCollisions() {
            if (!miniGameActive) return;
            let landedThisFrame = false;

            miniPlatforms.forEach(p => {
                let playerBottom = miniPlayer.y + miniPlayerHeight;
                let playerPrevBottom = miniPlayer.y - miniPlayer.vy + miniPlayerHeight;

                if (miniPlayer.vy >= 0 &&
                    playerBottom >= p.y &&
                    playerPrevBottom <= p.y + 1 &&
                    miniPlayer.x + miniPlayerWidth > p.x &&
                    miniPlayer.x < p.x + p.width
                ) {
                    miniPlayer.y = p.y - miniPlayerHeight;
                    miniPlayer.vy = 0;
                    landedThisFrame = true;
                }
            });

            miniPlayer.onGround = landedThisFrame;

            if (miniPlayer.y + miniPlayerHeight >= miniGameCanvas.height && !miniPlayer.onGround) {
                miniGameOver();
            }
        }

        function miniGameOver() {
            if (!miniGameActive) return;
            console.log("Mini-Game Over");
            miniGameActive = false;
            if (miniGameAnimationFrameId) {
                cancelAnimationFrame(miniGameAnimationFrameId);
                miniGameAnimationFrameId = null;
            }
            if (miniGameMusicPlayer) miniGameMusicPlayer.pause();
            if (miniGameSfx.gameOver) playMiniGameSound(miniGameSfx.gameOver);

            // Show a specific "mini-game over" message or just stop
            setTimeout(() => {
                miniGameCtx.clearRect(0, 0, miniGameCanvas.width, miniGameCanvas.height);
                drawMiniGameBackground();
                miniGameCtx.font = `${Math.floor(48 * miniScaleFactor * miniZoomOutFactor)}px Arial`;
                miniGameCtx.fillStyle = 'white';
                miniGameCtx.textAlign = 'center';
                miniGameCtx.shadowColor = 'black';
                miniGameCtx.shadowBlur = 5;
                miniGameCtx.fillText("MINI-GAME OVER", miniGameCanvas.width / 2, miniGameCanvas.height / 2 - (50 * miniScaleFactor * miniZoomOutFactor));
                miniGameCtx.font = `${Math.floor(28 * miniScaleFactor * miniZoomOutFactor)}px Arial`;
                miniGameCtx.fillText(`Final Score: ${miniScore}`, miniGameCanvas.width / 2, miniGameCanvas.height / 2 + (10 * miniScaleFactor * miniZoomOutFactor));
                miniGameCtx.fillText("Click to Restart Mini-Game", miniGameCanvas.width / 2, miniGameCanvas.height / 2 + (70 * miniScaleFactor * miniZoomOutFactor));
                miniGameCtx.shadowBlur = 0;
            }, 50);
        }

        function startMiniGame() {
            console.log("--- Starting Mini-Game ---");
            miniScore = 0;
            miniGameScoreElement.textContent = 'Score: 0';
            miniPlayer = { ...miniInitialPlayerState };
            initializeMiniGamePlatforms();
            miniGameActive = true;

            if (miniGameMusicPlayer) {
                miniGameMusicPlayer.currentTime = 0; // Rewind to start
                playMiniGameSound(miniGameMusicPlayer);
                console.log("--- Attempted mini-game music playback.");
            } else {
                console.log("--- Mini-game music player is null.");
            }

            if (miniGameAnimationFrameId) cancelAnimationFrame(miniGameAnimationFrameId);
            miniGameLoop();
        }

        function miniGameLoop() {
            if (!miniGameActive) {
                if (miniGameAnimationFrameId) {
                    cancelAnimationFrame(miniGameAnimationFrameId);
                    miniGameAnimationFrameId = null;
                }
                return;
            }
            miniGameCtx.clearRect(0, 0, miniGameCanvas.width, miniGameCanvas.height);
            drawMiniGameBackground();
            updateMiniGamePlayer();
            updateMiniGamePlatforms();
            checkMiniGameCollisions();
            drawMiniGamePlatforms();
            drawMiniGamePlayer();
            miniGameScoreElement.textContent = 'Score: ' + miniScore;
            miniGameAnimationFrameId = requestAnimationFrame(miniGameLoop);
        }

        function showMiniGameStartScreen() {
            console.log("Showing Mini-Game Start Screen...");
            drawMiniGameBackground();
            miniGameCtx.font = `${Math.floor(24 * miniScaleFactor * miniZoomOutFactor)}px Arial`;
            miniGameCtx.fillStyle = 'white';
            miniGameCtx.textAlign = 'center';
            miniGameCtx.shadowColor = 'black';
            miniGameCtx.shadowBlur = 2;
            miniGameCtx.fillText("Click to Start Mini-Game", miniGameCanvas.width / 2, miniGameCanvas.height / 2);
            miniGameCtx.shadowBlur = 0;
            miniGameScoreElement.textContent = 'Score: 0';
            console.log("showMiniGameStartScreen finished.");
        }

        // --- Mini-Game Mobile Controls Visibility Toggle ---
        miniGameMobileControlsMenuButton.addEventListener('click', () => {
            if (miniGameMobileControls.style.display === 'flex') {
                miniGameMobileControls.style.display = 'none';
                miniGameMobileControlsMenuButton.textContent = 'Show Mobile Controls';
            } else {
                miniGameMobileControls.style.display = 'flex';
                miniGameMobileControlsMenuButton.textContent = 'Hide Mobile Controls';
            }
        });


        // === INTEGRATION LOGIC ===

        function showMainMenu() {
            mainMenu.style.visibility = 'visible';
            mainMenu.style.opacity = '1';
            mainGameContainer.style.visibility = 'hidden';
            mainGameContainer.style.opacity = '0';
            miniGameContainer.style.visibility = 'hidden';
            miniGameContainer.style.opacity = '0';

            gameRunning = false;
            miniGameActive = false;

            // Stop any active game loops
            if (currentAnimationId) cancelAnimationFrame(currentAnimationId);
            currentAnimationId = null;
            if (miniGameAnimationFrameId) cancelAnimationFrame(miniGameAnimationFrameId);
            miniGameAnimationFrameId = null;

            // Stop any playing music/sfx
            if (mainGameMusicPlayer) mainGameMusicPlayer.pause();
            if (miniGameMusicPlayer) miniGameMusicPlayer.pause();

            // Hide all game-specific UI elements
            gameTimerDisplay.style.display = 'none';
            messageBox.style.display = 'none';
            mobileControls.style.display = 'none';
            mobileControlsMenuButton.style.display = 'none';
            miniGameMobileControls.style.display = 'none';
            miniGameMobileControlsMenuButton.style.display = 'none';
        }

        startButton.addEventListener('click', () => {
            showMainMenu(); // Ensure main menu is gone before showing game
            mainMenu.style.visibility = 'hidden';
            mainMenu.style.opacity = '0';
            mainGameContainer.style.visibility = 'visible';
            mainGameContainer.style.opacity = '1';
            gameTimerDisplay.style.display = 'block';
            mobileControlsMenuButton.style.display = 'block'; // Always show this button for 3D game

            // Initialize/Restart 3D game
            restartMainGame();
            console.log("3D Game Started.");
        });

        miniGameButton.addEventListener('click', () => {
            showMainMenu(); // Ensure main menu is gone before showing mini-game
            mainMenu.style.visibility = 'hidden';
            mainMenu.style.opacity = '0';
            miniGameContainer.style.visibility = 'visible';
            miniGameContainer.style.opacity = '1';
            miniGameMobileControlsMenuButton.style.display = 'block'; // Always show this button for mini-game

            // Show mini-game start screen
            showMiniGameStartScreen();
            console.log("2D Mini-Game screen displayed.");
            // The mini-game will start on first click on its canvas
        });

        backToMainMenuButton.addEventListener('click', showMainMenu);

        // Main game mobile controls visibility toggle
        mobileControlsMenuButton.addEventListener('click', () => {
            if (mobileControls.style.display === 'flex') {
                mobileControls.style.display = 'none';
                mobileControlsMenuButton.textContent = 'Show Mobile Controls';
            } else {
                mobileControls.style.display = 'flex';
                mobileControlsMenuButton.textContent = 'Hide Mobile Controls';
            }
        });

        // Initialize audio for both games on load, but don't play yet
        window.addEventListener('load', () => {
            loadMainGameAudio();
            loadMiniGameAudio();
            showMainMenu(); // Show main menu initially
        });

    </script>
</body>
</html>
