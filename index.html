<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Luckiest+Guy&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
        }
        canvas {
            display: block;
        }

        /* --- Main Menu Styles --- */
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 650px;
            padding: 50px 30px 30px 30px;

            /* Original image provides a good base, keep it */
            background-image: url('https://i.imgur.com/FhRSEjn.png');
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;

            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0,0,0,0.8);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            min-height: 400px;
            box-sizing: border-box;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            color: #E0FFFF;
            opacity: 1;
            visibility: visible;
            /* Adding a subtle glassy overlay for the menu itself */
            background-color: rgba(0, 50, 100, 0.2); /* A very subtle blue tint */
            backdrop-filter: blur(5px); /* Key to the glassy look */
            -webkit-backdrop-filter: blur(5px); /* Safari support */
            border: 1px solid rgba(255, 255, 255, 0.4); /* Light border */
        }

        /* --- Start Button Style (for main game) --- */
        #startButton {
            padding: 18px 40px;
            font-size: 2.2em;
            color: white; /* Text color */
            border: 1px solid rgba(0, 0, 0, 0.2); /* Darker, very subtle outer border */
            border-radius: 18px; /* Smooth rounded corners */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-top: auto;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            z-index: 51;
            margin-bottom: 20px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6); /* Slightly stronger text shadow */

            /* Core Frutiger Aero Blue Gradient */
            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 50%, #1A7DEE 100%);
            /* Combined Box Shadows for Depth and Glow */
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset, /* Top inner light reflection */
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,      /* Bottom inner shadow */
                0 5px 15px rgba(0, 0, 0, 0.4),          /* Standard outer shadow */
                0 0 15px rgba(100, 150, 255, 0.6);      /* Subtle outer blue glow */
        }

        #startButton:hover {
            /* Slightly lighter gradient on hover */
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 50%, #2A8DEE 100%);
            transform: translateY(-2px); /* Lift slightly on hover */
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 8px 20px rgba(0, 0, 0, 0.5), /* Stronger outer shadow */
                0 0 20px rgba(120, 170, 255, 0.8); /* Enhanced blue glow */
        }

        #startButton:active {
            background: linear-gradient(to bottom, #1A7DEE 0%, #3C9AF7 50%, #7DCFFF 100%); /* Invert gradient for pressed look */
            transform: translateY(0); /* Press down */
            box-shadow:
                0 0 5px rgba(0, 0, 0, 0.5) inset,
                0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* --- Mini-Game Button Style (similar to start button) --- */
        #miniGameButton {
            padding: 15px 35px;
            font-size: 1.8em;
            color: white;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-top: 10px;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            z-index: 51;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);

            /* Core Frutiger Aero Blue Gradient (slightly different shade perhaps, or same) */
            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 50%, #1A7DEE 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0, 0, 0, 0.4),
                0 0 15px rgba(100, 180, 255, 0.6);
        }
        #miniGameButton:hover {
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 50%, #2A8DEE 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 8px 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(120, 200, 255, 0.8);
        }
        #miniGameButton:active {
            background: linear-gradient(to bottom, #1A7DEE 0%, #3C9AF7 50%, #7DCFFF 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0, 0, 0, 0.5) inset,
                0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* --- NEW: External Game Button Style --- */
        #externalGameButton {
            padding: 12px 25px;
            font-size: 1.2em;
            color: white;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-top: 10px;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            z-index: 51;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
            /* A different, more vibrant color scheme */
            background: linear-gradient(to bottom, #FFA500 0%, #FF8C00 100%); /* Orange Gradient */
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0, 0, 0, 0.4),
                0 0 15px rgba(255, 165, 0, 0.6); /* Orange Glow */
        }
        #externalGameButton:hover {
            background: linear-gradient(to bottom, #FFB733 0%, #FF9E33 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 8px 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 185, 50, 0.8);
        }
        #externalGameButton:active {
            background: linear-gradient(to bottom, #FF8C00 0%, #FFA500 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0, 0, 0, 0.5) inset,
                0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* --- Mobile Controls Menu Button (top-left) --- */
        #mobileControlsMenuButton, #miniGameMobileControlsMenuButton {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            z-index: 51;

            border-radius: 8px; /* Slightly less rounded than main buttons */
            border: 1px solid rgba(0, 0, 0, 0.1); /* Very subtle border */
            /* Translucent blue-ish background with glassy reflection */
            background: linear-gradient(to bottom, rgba(125, 200, 255, 0.7) 0%, rgba(60, 120, 255, 0.7) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.5) inset, /* Top inner light reflection */
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,      /* Bottom inner shadow */
                0 2px 8px rgba(0,0,0,0.3);              /* Standard outer shadow */
            backdrop-filter: blur(3px); /* Add blur for glassy effect */
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.2s ease-in-out;
        }
        #miniGameMobileControlsMenuButton {
            top: 50px; /* Different position from main game's button */
            left: 15px;
            display: none; /* Hidden by default */
        }
        #mobileControlsMenuButton:hover, #miniGameMobileControlsMenuButton:hover {
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.8) 0%, rgba(40, 100, 255, 0.8) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.7) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.4);
            transform: translateY(-1px);
        }
        #mobileControlsMenuButton:active, #miniGameMobileControlsMenuButton:active {
            background: linear-gradient(to bottom, rgba(60, 120, 255, 0.7) 0%, rgba(125, 200, 255, 0.7) 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
        }


        #messageBox {
            display: none; /* Hidden by default */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px;
            text-align: center;
            z-index: 100;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            /* Frutiger Aero for message box */
            background: linear-gradient(to bottom, rgba(0, 70, 140, 0.8) 0%, rgba(0, 30, 80, 0.8) 100%); /* Darker blue gradient */
            border: 1px solid rgba(255, 255, 255, 0.4); /* Lighter border */
            border-radius: 15px;
            backdrop-filter: blur(8px); /* Stronger blur for pop-up */
            -webkit-backdrop-filter: blur(8px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 0 25px rgba(0, 100, 200, 0.7); /* Blue glow */
        }
        #messageBox h2 {
            margin-top: 0;
            font-size: 2.2em;
            color: #4CAF50; /* Keep green for success, or change to a blue success tone */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        #messageBox button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: white;
            cursor: pointer;
            font-family: 'Luckiest Guy', 'Kalam', 'Comic Sans MS', cursive, sans-serif;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;

            border-radius: 8px; /* Softer corners */
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #7DCFFF 0%, #3C9AF7 100%); /* Blue gradient for restart button */
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.3);
        }
        #messageBox button:hover {
            background: linear-gradient(to bottom, #8CDFFF 0%, #4CAAF7 100%);
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 5px 15px rgba(0,0,0,0.4);
        }
        #messageBox button:active {
            background: linear-gradient(to bottom, #3C9AF7 0%, #7DCFFF 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- Fullscreen Button Styles --- */
        #fullscreenButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            line-height: 1;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            
            border-radius: 8px; /* Slightly less rounded */
            border: 1px solid rgba(0, 0, 0, 0.1);
            /* Translucent blue-ish background with glassy reflection */
            background: linear-gradient(to bottom, rgba(125, 200, 255, 0.7) 0%, rgba(60, 120, 255, 0.7) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.5) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 2px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(3px); /* Glassy effect */
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.2s ease-in-out;
        }
        #fullscreenButton:hover {
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.8) 0%, rgba(40, 100, 255, 0.8) 100%);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.7) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.4);
            transform: translateY(-1px);
        }
        #fullscreenButton:active {
            background: linear-gradient(to bottom, rgba(60, 120, 255, 0.7) 0%, rgba(125, 200, 255, 0.7) 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
        }

        /* --- Mobile Controls (Joystick for 3D Game) --- */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            justify-content: space-between;
            align-items: flex-end;
            z-index: 20;
            /* pointer-events: none; Removed this from parent */
        }

        /* Joystick Base */
        #joystick-base {
            position: relative; /* Allows knob to be positioned absolutely within it */
            width: 150px; /* Size of the joystick area */
            height: 150px;
            border-radius: 50%; /* Make it a circle */
            pointer-events: auto; /* Make the base interactive for touch */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex; /* For centering the knob */
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease-in-out;

            /* Base Frutiger Aero look */
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.4) 0%, rgba(60, 120, 255, 0.4) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset, /* Subtle top inner reflection */
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,      /* Subtle bottom inner shadow */
                0 3px 10px rgba(0,0,0,0.4),             /* Standard outer shadow */
                0 0 15px rgba(100, 180, 255, 0.5);      /* Soft blue glow */
            backdrop-filter: blur(4px); /* Glassy blur */
            -webkit-backdrop-filter: blur(4px);
        }

        /* Joystick Knob */
        #joystick-knob {
            position: absolute; /* Positioned relative to #joystick-base */
            width: 70px; /* Size of the movable knob */
            height: 70px;
            border-radius: 50%; /* Make it a circle */
            cursor: grab; /* Indicates it's draggable */
            transition: all 0.1s ease;

            /* Knob Frutiger Aero look */
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9) 0%, rgba(150, 200, 255, 0.9) 100%); /* Very light to light blue */
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset, /* Strong inner highlight for gloss */
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,      /* Inner bottom shadow */
                0 2px 8px rgba(0,0,0,0.4);              /* Standard outer shadow */
        }
        #joystick-knob:active {
            background: linear-gradient(to bottom, rgba(180, 210, 240, 0.9) 0%, rgba(130, 180, 230, 0.9) 100%);
            cursor: grabbing;
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.4);
        }

        /* Jump button */
        #jump-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
            pointer-events: auto; /* Make interactive */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Luckiest Guy', 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease-in-out;

            /* Jump button Frutiger Aero look */
            background: linear-gradient(to bottom, #00BFFF 0%, #1E90FF 100%); /* Deep Sky Blue to Dodger Blue */
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0,0,0,0.4),
                0 0 20px rgba(0, 191, 255, 0.7); /* Blue glow */
        }
        #jump-button:active {
            background: linear-gradient(to bottom, #1E90FF 0%, #00BFFF 100%); /* Invert gradient for pressed */
            transform: translateY(1px); /* Press down */
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- Main Game Container (holds 3D canvas and its UI) --- */
        #mainGameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            /* Initially hidden, will be revealed when 3D game starts */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }
        #mainGameContainer canvas { /* Style for the Three.js canvas */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* --- 3D Game Timer Display --- */
        #gameTimerDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.8em;
            font-family: 'Luckiest Guy', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.3); /* Semi-transparent background */
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none; /* Hidden by default, shown when 3D game starts */
        }


        /* --- Mini-Game Specific Styles --- */
        #miniGameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Black background for the mini-game */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align canvas to top */
            flex-direction: column; /* To stack canvas and score if needed */
            z-index: 60; /* Higher than main game menu but lower than messages */
            /* Initially hidden */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }

        #miniGameCanvas {
            border: 2px solid white;
            background-color: black;
            margin-top: auto; /* Push canvas to center vertically with controls at bottom */
        }

        #miniGameScore {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            font-family: 'Luckiest Guy', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 61; /* Above canvas */
            /* Some Frutiger Aero for score display */
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 15px;
            border-radius: 8px;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #backToMainMenuButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: white;
            cursor: pointer;
            font-family: 'Luckiest Guy', cursive;
            z-index: 61; /* Ensure it's above canvas */
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;

            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            /* Keep red for "back" but with Frutiger Aero gradients */
            background: linear-gradient(to bottom, #DC143C 0%, #8B0000 100%); /* Crimson to Dark Red */
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.4) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 3px 10px rgba(0,0,0,0.3);
        }
        #backToMainMenuButton:hover {
            background: linear-gradient(to bottom, #8B0000 0%, #DC143C 100%); /* Invert gradient on hover */
            transform: translateY(-2px);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset,
                0 5px 15px rgba(0,0,0,0.4);
        }
        #backToMainMenuButton:active {
            background: linear-gradient(to bottom, #8B0000 0%, #DC143C 100%);
            transform: translateY(0);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }

        /* --- NEW: Mini-Game Mobile Controls Styles --- */
        #mini-game-mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            justify-content: space-between;
            align-items: flex-end;
            z-index: 70; /* Higher than mini-game canvas */
            /* pointer-events: none; Removed this from parent */
            margin-bottom: 20px; /* Space from bottom */
        }

        #mini-joystick-base {
            position: relative;
            width: 130px; /* Slightly smaller for mini-game */
            height: 130px;
            border-radius: 50%;
            pointer-events: auto; /* Make interactive */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, rgba(100, 180, 255, 0.4) 0%, rgba(60, 120, 255, 0.4) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 3px 10px rgba(0,0,0,0.4),
                0 0 15px rgba(100, 180, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        #mini-joystick-knob {
            position: absolute;
            width: 60px; /* Slightly smaller */
            height: 60px;
            border-radius: 50%;
            cursor: grab;
            transition: all 0.1s ease;

            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9) 0%, rgba(150, 200, 255, 0.9) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }
        #mini-joystick-knob:active {
            background: linear-gradient(to bottom, rgba(180, 210, 240, 0.9) 0%, rgba(130, 180, 230, 0.9) 100%);
            cursor: grabbing;
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 1px 5px rgba(0,0,0,0.4);
        }

        #mini-jump-button {
            width: 90px; /* Slightly smaller */
            height: 90px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: bold;
            color: white;
            pointer-events: auto; /* Make interactive */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Luckiest Guy', 'Kalam', cursive;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
            transition: all 0.2s ease-in-out;

            background: linear-gradient(to bottom, #4682B4 0%, #6A5ACD 100%); /* SteelBlue to SlateBlue for mini-game */
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow:
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 5px 15px rgba(0,0,0,0.4),
                0 0 20px rgba(70, 130, 180, 0.7);
        }
        #mini-jump-button:active {
            transform: translateY(1px); /* Press down */
            background: linear-gradient(to bottom, #6A5ACD 0%, #4682B4 100%);
            box-shadow:
                0 0 5px rgba(0,0,0,0.5) inset,
                0 2px 8px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="mainGameContainer">
        <div id="messageBox">
            <h2 id="messageText"></h2>
            <button id="restartButton">Play Again</button>
        </div>
        <div id="fullscreenButton" title="Toggle Fullscreen">
            &#x26F6;
        </div>
        <div id="gameTimerDisplay">Time: 00:00.00</div> <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
            <div id="jump-button">JUMP</div>
        </div>
    </div>

    <div id="mainMenu">
        <button id="mobileControlsMenuButton">Show Mobile Controls</button>
        <button id="startButton">Start 3D Game</button>
        <buton id="miniGameButton"></button>
        <button id="externalGameButton">Play 2d mini game!</button>
    </div>

    <div id="miniGameContainer">
        <canvas id="miniGameCanvas"></canvas>
        <div id="miniGameScore">Score: 0</div>
        <button id="backToMainMenuButton">Back to Main Menu</button>
        <div id="mini-game-mobile-controls">
            <div id="mini-joystick-base">
                <div id="mini-joystick-knob"></div>
            </div>
            <div id="mini-jump-button">JUMP</div>
        </div>
        <button id="miniGameMobileControlsMenuButton">Show Mobile Controls</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // === GLOBAL GAME STATE FLAGS ===
        let gameRunning = false;    // True if 3D game is active
        let miniGameActive = false; // True if 2D mini-game is active

        // === GLOBAL REFERENCES FOR MINI-GAME AUDIO (allows stopping from outside its scope) ===
        let miniGameMusicPlayer = null; // Stores the SourceNode and GainNode
        let miniGameSfx = {}; // Will hold jump, land, gameOver sounds for mini-game

        // === GLOBAL ASSET DEFAULTS (from 3D game) ===
        const DEFAULT_3D_PLAYER_SKIN_URL = 'https://i.imgur.com/cV6r1ty.png';
        const DEFAULT_3D_MUSIC_URL = 'https://ia600900.us.archive.org/26/items/music1_20250625/music1.mp3';


        // === Three.js Setup (Main Game) ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        const mainGameContainer = document.getElementById('mainGameContainer');
        mainGameContainer.appendChild(renderer.domElement); // Append 3D game canvas to its container

        // === Physics World (Main Game) ===
        if (typeof CANNON === 'undefined') {
            console.error("ERROR: CANNON.js library is not loaded! Physics will not work. Please ensure it's loaded from a working CDN.");
            alert("CANNON.js physics library failed to load. The game's physics will not function. This could be due to network restrictions.");
        } else {
            console.log("CANNON.js library detected. Initializing physics world.");
        }

        const world = new CANNON.World();
        world.gravity.set(0, -20, 0);  
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 20;  
        world.solver.tolerance = 0.001;  
        world.defaultContactMaterial.friction = 0.5;  
        world.defaultContactMaterial.restitution = 0.1;  
        console.log("CANNON.js physics world initialized.");

        // === Lighting (Main Game) ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        scene.add(directionalLight);

        // === Player (Main Game) ===
        const playerSize = 1.5;
        const textureLoader = new THREE.TextureLoader();
        const playerTexture = textureLoader.load(
            DEFAULT_3D_PLAYER_SKIN_URL, // Using global constant here
            undefined,
            undefined,
            (err) => {
                console.error('An error happened loading the player texture.', err);
                playerMesh.material = new THREE.MeshLambertMaterial({ color: 0xff4500 }); // Fallback color
                playerMesh.material.needsUpdate = true;
            }
        );

        const playerGeo = new THREE.PlaneGeometry(playerSize, playerSize);
        const playerMat = new THREE.MeshLambertMaterial({
            map: playerTexture,
            color: 0xffffff,
            transparent: true,
            side: THREE.DoubleSide
        });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // --- Physics Material for Player ---
        const playerPhysicsMaterial = new CANNON.Material("playerMaterial");
        const playerShape = new CANNON.Box(new CANNON.Vec3(playerSize / 2, playerSize / 2, 0.5));  
        const playerBody = new CANNON.Body({ mass: 5, shape: playerShape, material: playerPhysicsMaterial });
        playerBody.allowSleep = false;  
        playerBody.fixedRotation = true;
        playerBody.linearDamping = 0.1;
        playerBody.angularDamping = 0.9;

        let startPosition = new CANNON.Vec3(0, 5, 0);  
        playerBody.position.copy(startPosition);
        world.addBody(playerBody);
        console.log("Player physics body created and added to world. fixedRotation set to true.");

        // === Platforms (Main Game) ===
        let platforms = [];
        const winPlatformMaterial = new CANNON.Material("winPlatformMaterial");
        const regularPlatformMaterial = new CANNON.Material("regularPlatformMaterial");
        let endPlatformBody = null;

        // --- Define contact materials for physics interactions ---
        const playerRegularContactMaterial = new CANNON.ContactMaterial(
            playerPhysicsMaterial,
            regularPlatformMaterial,
            {
                friction: 0.5,
                restitution: 0.05
            }
        );
        world.addContactMaterial(playerRegularContactMaterial);

        const playerWinContactMaterial = new CANNON.ContactMaterial(
            playerPhysicsMaterial,
            winPlatformMaterial,
            {
                friction: 1.0,
                restitution: 0.0,
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            }
        );
        world.addContactMaterial(playerWinContactMaterial);

        function createPlatform(size, position, color = 0xaaaaaa, isWinPlatform = false) {
            const platformGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const platformMat = new THREE.MeshLambertMaterial({ color: color });
            const platformMesh = new THREE.Mesh(platformGeo, platformMat);
            platformMesh.position.copy(position);
            platformMesh.receiveShadow = true;
            scene.add(platformMesh);

            const platformShape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
            const platformBody = new CANNON.Body({
                mass: 0, // Static body
                shape: platformShape,
                position: position,
                material: isWinPlatform ? winPlatformMaterial : regularPlatformMaterial
            });
            world.addBody(platformBody);
            return { mesh: platformMesh, body: platformBody };
        }

        // --- Random Level Generation ---
        function clearCurrentLevel() {
            platforms.forEach(p => {
                scene.remove(p.mesh);
                world.removeBody(p.body);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            platforms = [];
            endPlatformBody = null;
        }

        function generateRandomLevel() {
            clearCurrentLevel();

            const startPlatSize = { x: 10, y: 1, z: 10 };
            const startPlatPos = { x: 0, y: 0, z: 0 };
            platforms.push(createPlatform(startPlatSize, new THREE.Vector3(startPlatPos.x, startPlatPos.y, startPlatPos.z)));
            
            startPosition.set(startPlatPos.x, startPlatPos.y + 5, startPlatPos.z);  

            let lastPlatformPos = new THREE.Vector3(startPlatPos.x, startPlatPos.y, startPlatPos.z);

            const numPlatforms = Math.floor(Math.random() * 8) + 7;

            for (let i = 0; i < numPlatforms; i++) {
                let newPlatformX, newPlatformY, newPlatformZ;
                let newPlatformSizeX = Math.random() * 5 + 3;
                let newPlatformSizeZ = Math.random() * 5 + 3;
                let newPlatformSizeY = 1;

                newPlatformX = lastPlatformPos.x + (Math.random() * 20 - 10);
                newPlatformZ = lastPlatformPos.z + (Math.random() * 20 - 10);
                newPlatformY = lastPlatformPos.y + (Math.random() * 6 - 2);
                newPlatformY = Math.max(newPlatformY, -10);

                const isWinPlat = (i === numPlatforms - 1);

                const newPlatform = createPlatform(
                    { x: newPlatformSizeX, y: newPlatformSizeY, z: newPlatformSizeZ },
                    new THREE.Vector3(newPlatformX, newPlatformY, newPlatformZ),
                    isWinPlat ? 0x00ff00 : 0xaaaaaa,
                    isWinPlat
                );
                platforms.push(newPlatform);
                lastPlatformPos = newPlatform.mesh.position;

                if (isWinPlat) {
                    endPlatformBody = newPlatform.body;
                }
            }
        }

        generateRandomLevel();

        // --- Music Setup (Main Game) ---
        const listener = new THREE.AudioListener();
        camera.add(listener);

        const backgroundMusic = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        const musicUrl = DEFAULT_3D_MUSIC_URL; // Using global constant here
        let musicLoaded = false; // Flag to check if music buffer is loaded

        audioLoader.load(musicUrl, function(buffer) {
            backgroundMusic.setBuffer(buffer);
            backgroundMusic.setLoop(true);
            backgroundMusic.setVolume(0.5);
            musicLoaded = true;
            console.log("3D game music buffer loaded.");
        }, undefined, function(err) {
            console.error('An error occurred loading the background music:', err);
            musicLoaded = false;
        });

        function playBackgroundMusic() {
            if (musicLoaded) {
                // Check if already playing or paused
                if (!backgroundMusic.isPlaying && backgroundMusic.buffer) {
                    backgroundMusic.play();
                    console.log("3D game music started/resumed.");
                } else if (backgroundMusic.isPlaying) {
                    // Already playing, do nothing
                } else if (backgroundMusic.buffer && backgroundMusic.isPaused) {
                    backgroundMusic.play(); // This is the correct way to resume Three.js Audio
                    console.log("3D game music resumed from paused state.");
                } else if (backgroundMusic.buffer && !backgroundMusic.isPlaying) {
                    // If not playing and not explicitly paused (e.g., initial state), start it
                    backgroundMusic.play();
                    console.log("3D game music started for the first time.");
                }
            } else {
                console.warn("3D game music not yet loaded, cannot play.");
            }
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && backgroundMusic.isPlaying) {
                backgroundMusic.pause();
                console.log("3D game music paused.");
            }
        }

        // --- Jump Sound Setup (Main Game) ---
        const jumpSound = new THREE.Audio(listener);
        const jumpSoundUrl = 'https://ia801508.us.archive.org/17/items/jump_20250625/jump.mp3';
        let jumpSoundBuffer = null;

        audioLoader.load(jumpSoundUrl, function(buffer) {
            jumpSoundBuffer = buffer;
            jumpSound.setBuffer(jumpSoundBuffer);
            jumpSound.setVolume(0.7);
        }, undefined, function(err) {
            console.error('An error occurred loading the jump sound:', err);
        });

        // --- Game Over Sound Setup (Main Game) ---
        const gameOverSound = new THREE.Audio(listener);
        const gameOverSoundUrl = 'https://ia600700.us.archive.org/13/items/gameover_202507/gameOver.mp3';
        let gameOverSoundBuffer = null;

        audioLoader.load(gameOverSoundUrl, function(buffer) {
            gameOverSoundBuffer = buffer;
            gameOverSound.setBuffer(gameOverSoundBuffer);
            gameOverSound.setVolume(0.8);
        }, undefined, function(err) {
            console.error('An error occurred loading the game over sound:', err);
        });


        // === Keyboard Controls (Main Game's internal handler) ===
        const keys = {}; // Moved keys into main game scope
        function handleKeyDown(e) {
            keys[e.code] = true;
        }
        function handleKeyUp(e) {
            keys[e.code] = false;
        }

        let canJump = false;
        const contactNormal = new CANNON.Vec3();
        const up = new CANNON.Vec3(0, 1, 0);

        playerBody.addEventListener("collide", (e) => {
            const contact = e.contact;
            if (contact.bi.id === playerBody.id) {  
                contact.ni.negate(contactNormal);  
            } else {  
                contactNormal.copy(contact.ni);  
            }

            if (contactNormal.dot(up) > 0.5) {  
                if (!canJump) {  
                    canJump = true;
                }
            } else {
                if (canJump) {  
                    canJump = false;
                }
            }
            
            if (endPlatformBody && (e.body === endPlatformBody)) {
                if (playerBody.velocity.y < 0.1 && contactNormal.dot(up) > 0.8) {
                    console.log("Player reached win platform! Generating new level.");
                    showMessage("You win! Next Level!", true, '3D'); // Pass 'true' for win
                }
            }
        });

        function handleMainGameKeyboardControls() {
            const speed = 10;  
            const jumpForce = 15;

            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;  
            cameraDirection.normalize();

            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();  

            let moveDirection = new THREE.Vector3();

            if (keys['KeyW'] || keys['ArrowUp']) {
                moveDirection.add(cameraDirection);
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveDirection.sub(cameraDirection);
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection.sub(right);
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection.add(right);
            }

            let currentYVelocity = playerBody.velocity.y;

            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize().multiplyScalar(speed);
                playerBody.velocity.x = moveDirection.x;
                playerBody.velocity.z = moveDirection.z;
            } else {
                if (playerBody.velocity.x !== 0 || playerBody.velocity.z !== 0) {
                    playerBody.velocity.x = 0;
                    playerBody.velocity.z = 0;
                }
            }
            
            playerBody.velocity.y = currentYVelocity;  

            if ((keys['Space']) && canJump) {
                playerBody.velocity.y = jumpForce;
                canJump = false;

                if (jumpSoundBuffer) {
                    if (jumpSound.isPlaying) {
                        jumpSound.stop();
                    }
                    jumpSound.play();
                }
            }
        }


        // === Mobile Controls Logic (Joystick for 3D Game) ===
        const mobileControlsDiv = document.getElementById('mobile-controls');
        const jumpButton = document.getElementById('jump-button');
        const mobileControlsMenuButton = document.getElementById('mobileControlsMenuButton');

        // Joystick elements
        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');

        let isJoystickActive = false;
        let joystickCenter = { x: 0, y: 0 }; // Center of the base
        let maxJoystickDistance = joystickBase.offsetWidth / 2 - joystickKnob.offsetWidth / 2;
        let currentJoystickPos = { x: 0, y: 0 }; // Normalized -1 to 1 values

        // Get the absolute position of the joystick base on the screen once it's rendered
        function updateJoystickBasePosition() {
            const rect = joystickBase.getBoundingClientRect();
            joystickCenter.x = rect.left + rect.width / 2;
            joystickCenter.y = rect.top + rect.height / 2;
            maxJoystickDistance = joystickBase.offsetWidth / 2 - joystickKnob.offsetWidth / 2;
            // Ensure knob starts centered
            joystickKnob.style.left = '50%';
            joystickKnob.style.top = '50%';
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        // Call this when mobile controls are shown or on window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight); // Keep 3D canvas resized
            if (mobileControlsVisible) {
                updateJoystickBasePosition();
            }
            if (miniGameActive && miniGameMobileControlsVisible) {
                updateMiniJoystickBasePosition(); // Update for mini-game controls too
            }
        });

        // Event listeners for 3D game joystick
        joystickBase.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            e.preventDefault(); // Prevent scrolling/zooming
            isJoystickActive = true;
            updateJoystickBasePosition();
            const touch = e.touches[0];
            moveJoystickKnob(touch.clientX, touch.clientY);
        }, { passive: false }); // Use passive: false to allow preventDefault

        joystickBase.addEventListener('touchmove', (e) => {
            if (!isJoystickActive || !gameRunning) return;
            e.preventDefault();
            const touch = e.touches[0];
            moveJoystickKnob(touch.clientX, touch.clientY);
        }, { passive: false });

        joystickBase.addEventListener('touchend', () => {
            isJoystickActive = false;
            resetJoystickKnob();
            currentJoystickPos = { x: 0, y: 0 };
        });

        function moveJoystickKnob(clientX, clientY) {
            let offsetX = clientX - joystickCenter.x;
            let offsetY = clientY - joystickCenter.y;

            const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);

            if (distance > maxJoystickDistance) {
                offsetX = (offsetX / distance) * maxJoystickDistance;
                offsetY = (offsetY / distance) * maxJoystickDistance;
            }

            // Set knob position relative to its parent for smooth movement within the base
            joystickKnob.style.transform = `translate(${offsetX - joystickKnob.offsetWidth / 2}px, ${offsetY - joystickKnob.offsetHeight / 2}px)`;

            // Update normalized joystick position (-1 to 1)
            currentJoystickPos.x = offsetX / maxJoystickDistance;
            currentJoystickPos.y = offsetY / maxJoystickDistance;
        }

        function resetJoystickKnob() {
            joystickKnob.style.left = '50%';
            joystickKnob.style.top = '50%';
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        let mobileControlsVisible = false; // To track visibility
        mobileControlsMenuButton.addEventListener('click', () => {
            mobileControlsVisible = !mobileControlsVisible;
            mobileControlsDiv.style.display = mobileControlsVisible ? 'flex' : 'none';
            if (mobileControlsVisible) {
                updateJoystickBasePosition(); // Ensure joystick is positioned correctly
            }
        });


        // Universal mobile jump handler
        function handleMobileJump(gameType) {
            if (gameType === '3D') {
                if (canJump) {
                    playerBody.velocity.y = 15; // Jump force for 3D game
                    canJump = false; // Set canJump to false immediately

                    if (jumpSoundBuffer) {
                        if (jumpSound.isPlaying) {
                            jumpSound.stop();
                        }
                        jumpSound.play();
                    }
                }
            } else if (gameType === '2D') {
                 if (!miniPlayer.isJumping && miniPlayer.grounded) {
                    miniPlayer.dy = miniPlayer.jumpStrength;
                    miniPlayer.isJumping = true;
                    miniPlayer.grounded = false;
                    if (miniGameJumpSoundBuffer) miniGameSfx.play(miniGameJumpSoundBuffer, false, 0.7);
                }
            }
        }

        // Apply to main game jump button
        jumpButton.addEventListener('touchstart', (e) => { // Use touchstart for mobile
            if (gameRunning) {
                e.preventDefault(); // Prevent default touch behavior
                handleMobileJump('3D');
            }
        }, { passive: false });
        jumpButton.addEventListener('click', () => { // Keep click for desktop testing
             if (gameRunning) {
                handleMobileJump('3D');
            }
        });


        function handleMainGameMobileControls() {
            if (!mobileControlsVisible) return;

            const speed = 10;

            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();

            let moveDirection = new THREE.Vector3();

            // Use joystick input for movement
            if (Math.abs(currentJoystickPos.x) > 0.1 || Math.abs(currentJoystickPos.y) > 0.1) {
                // Calculate forward/backward movement
                moveDirection.addScaledVector(cameraDirection, -currentJoystickPos.y);
                // Calculate left/right movement
                moveDirection.addScaledVector(right, currentJoystickPos.x);

                moveDirection.normalize().multiplyScalar(speed);
                playerBody.velocity.x = moveDirection.x;
                playerBody.velocity.z = moveDirection.z;
            } else {
                // Decelerate if joystick is centered
                playerBody.velocity.x = 0;
                playerBody.velocity.z = 0;
            }

            playerBody.velocity.y = playerBody.velocity.y; // Preserve vertical velocity
        }


        // === Game State Management ===
        const mainMenu = document.getElementById('mainMenu');
        const startButton = document.getElementById('startButton');
        const miniGameButton = document.getElementById('miniGameButton');
        const externalGameButton = document.getElementById('externalGameButton'); // Get the new button
        const backToMainMenuButton = document.getElementById('backToMainMenuButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const gameTimerDisplay = document.getElementById('gameTimerDisplay'); // Get timer display element

        let lastGameMode = null; // To store which game was active before message box
        let startTime = 0; // Stores the timestamp when the timer starts
        let gameTimerIntervalId = null; // Stores the ID of the setInterval for the timer

        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const ms = Math.floor((milliseconds % 1000) / 10); // Get two digits for milliseconds

            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
        }

        function startTimer() {
            if (gameTimerIntervalId) {
                clearInterval(gameTimerIntervalId); // Clear any existing timer
            }
            startTime = performance.now(); // Record the start time
            gameTimerDisplay.style.display = 'block'; // Show the timer
            gameTimerIntervalId = setInterval(updateTimerDisplay, 10); // Update every 10ms for precision
        }

        function stopTimer() {
            if (gameTimerIntervalId) {
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = null;
            }
        }

        function updateTimerDisplay() {
            if (gameRunning) { // Only update if the 3D game is actively running
                const currentTime = performance.now();
                const elapsed = currentTime - startTime;
                gameTimerDisplay.textContent = `Time: ${formatTime(elapsed)}`;
            }
        }

        function showMainMenu() {
            mainMenu.style.opacity = 1;
            mainMenu.style.visibility = 'visible';
            mainGameContainer.style.opacity = 0;
            mainGameContainer.style.visibility = 'hidden';
            miniGameContainer.style.opacity = 0;
            miniGameContainer.style.visibility = 'hidden';
            mobileControlsDiv.style.display = 'none'; // Hide 3D game controls
            miniGameMobileControlsDiv.style.display = 'none'; // Hide 2D game controls
            miniGameMobileControlsMenuButton.style.display = 'none'; // Hide mini-game control toggle
            mobileControlsMenuButton.style.display = 'block'; // Show main game control toggle on menu
            gameRunning = false;
            miniGameActive = false;

            stopTimer(); // Stop the 3D game timer
            gameTimerDisplay.style.display = 'none'; // Hide the timer display

            if (backgroundMusic && backgroundMusic.isPlaying) {
                pauseBackgroundMusic(); // Use the pause function
            }
            // Ensure mini-game music is stopped too
            if (miniGameMusicPlayer && miniGameMusicPlayer.isPlaying) {
                miniGameMusicPlayer.source.stop(); // Stop mini-game music
                miniGameMusicPlayer.isPlaying = false;
                miniGameMusicPlayer = null; // Clear the reference
            }
        }

        function startGame() {
            mainMenu.style.opacity = 0;
            mainMenu.style.visibility = 'hidden';
            mainGameContainer.style.opacity = 1;
            mainGameContainer.style.visibility = 'visible';
            mobileControlsMenuButton.style.display = 'none'; // Hide main game control toggle
            gameRunning = true;
            miniGameActive = false; // Ensure mini-game is not active
            playBackgroundMusic(); // This will resume or start if not already playing
            resetPlayer();
            startTimer(); // Start the timer when the 3D game begins
            // Ensure mobile controls are hidden initially, show only if toggled
            mobileControlsDiv.style.display = mobileControlsVisible ? 'flex' : 'none';
        }

        function resetPlayer() {
            playerBody.position.copy(startPosition);
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);
            canJump = true;
            // Timer logic: if it's a reset during gameplay, restart timer
            if (gameRunning) { // Only restart timer if game is already considered running (e.g., after a win)
                startTimer();
            } else { // If reset from game over, it will be started by startGame()
                gameTimerDisplay.textContent = 'Time: 00:00.00'; // Reset display immediately
            }
        }

        function showMessage(text, isWin, gameMode = '3D') { // Added gameMode parameter
            messageBox.style.display = 'block';
            restartButton.textContent = isWin ? 'Play New Level' : 'Try Again';
            gameRunning = false; // Pause 3D game
            miniGameActive = false; // Pause 2D game
            lastGameMode = gameMode; // Store which game was active

            // NEW: Store whether it was a win for the 3D game
            messageBox.dataset.wasWin = isWin && gameMode === '3D' ? 'true' : 'false';

            pauseBackgroundMusic(); // Pause 3D game music
            if (miniGameMusicPlayer && miniGameMusicPlayer.isPlaying) {
                miniGameMusicPlayer.source.stop(); // Stop mini-game music
                miniGameMusicPlayer.isPlaying = false;
            }

            if (isWin && gameMode === '3D') {
                stopTimer(); // Stop the timer when the 3D game is won
                const finalTime = performance.now() - startTime;
                messageText.textContent = `${text} Your time: ${formatTime(finalTime)}`;
            } else {
                messageText.textContent = text;
            }
            gameTimerDisplay.style.display = 'none'; // Hide timer when message box is up
        }

        function hideMessage() {
            messageBox.style.display = 'none';
            const was3DWin = messageBox.dataset.wasWin === 'true';

            if (lastGameMode === '3D') {
                // NEW: Reset all keyboard input states
                for (const key in keys) {
                    keys[key] = false;
                }

                // NEW: Reset mobile joystick state for the 3D game
                isJoystickActive = false;
                currentJoystickPos = { x: 0, y: 0 };
                resetJoystickKnob(); // Visually reset the knob to center

                if (was3DWin) {
                    generateRandomLevel(); // Generate a new level ONLY if it was a 3D game win
                }
                startGame(); // Start/resume 3D game (this will reset player, start timer, etc.)
            } else if (lastGameMode === '2D') {
                // NEW: Reset mini-game mobile joystick state
                isMiniJoystickActive = false;
                currentMiniJoystickPos = { x: 0, y: 0 };
                resetMiniJoystickKnob(); // Visually reset the mini-game knob to center

                startMiniGame(); // Resume/Restart 2D game
            }

            // Clean up the data attribute
            delete messageBox.dataset.wasWin;
        }


        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', hideMessage); // Simplified, hides and restarts the game
        
        // --- NEW: External Game Button functionality ---
        externalGameButton.addEventListener('click', () => {
            window.location.href = 'https://imacman9.github.io/2dplatformer/';
        });

        // === Fullscreen Toggle ===
        const fullscreenButton = document.getElementById('fullscreenButton');
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        fullscreenButton.addEventListener('click', toggleFullscreen);


        // === Main Game Animation Loop ===
        const timeStep = 1 / 60; // seconds
        let lastTime;

        function animate(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;

            if (gameRunning) {
                world.step(timeStep, deltaTime);

                playerMesh.position.copy(playerBody.position);
                playerMesh.quaternion.copy(playerBody.quaternion);

                // Make player always face the camera
                playerMesh.lookAt(camera.position);

                // Camera follows player
                camera.position.x = playerMesh.position.x + 10;
                camera.position.y = playerMesh.position.y + 10;
                camera.position.z = playerMesh.position.z + 10;
                camera.lookAt(playerMesh.position);

                // Handle controls
                handleMainGameKeyboardControls();
                handleMainGameMobileControls();

                // Check for fall off
                if (playerMesh.position.y < -20) {
                    if (gameOverSoundBuffer && !gameOverSound.isPlaying) {
                        gameOverSound.play();
                    }
                    showMessage("Game Over! You fell off.", false, '3D'); // Specify gameMode
                }
            }
            renderer.render(scene, camera);
            lastTime = currentTime;
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);


        // === 2D Mini-Game Logic ===
        const miniGameCanvas = document.getElementById('miniGameCanvas');
        const miniGameCtx = miniGameCanvas.getContext('2d');
        const miniGameScoreDisplay = document.getElementById('miniGameScore');
        const miniGameContainer = document.getElementById('miniGameContainer');

        const MINI_GAME_WIDTH = 800;
        const MINI_GAME_HEIGHT = 400;
        miniGameCanvas.width = MINI_GAME_WIDTH;
        miniGameCanvas.height = MINI_GAME_HEIGHT;

        // Mini-Game Player
        let miniPlayer = {
            x: 50,
            y: MINI_GAME_HEIGHT - 30,
            width: 20,
            height: 20,
            dy: 0,
            gravity: 0.5,
            jumpStrength: -10,
            isJumping: false,
            grounded: true
        };

        // Mini-Game Obstacles
        let obstacles = [];
        let obstacleSpeed = 5;
        let obstacleInterval = 2000; // Milliseconds
        let lastObstacleTime = 0;
        let minObstacleGap = 300; // Minimum horizontal gap between obstacles

        // Mini-Game Score
        let miniGameScore = 0;
        let miniGameFrameCount = 0;

        // Mini-Game Audio
        const miniGameAudioListener = new AudioContext(); // Separate AudioContext for mini-game
        let miniGameBackgroundMusicBuffer;
        let miniGameJumpSoundBuffer;
        let miniGameLandSoundBuffer;
        let miniGameOverSoundBuffer;

        const miniGameMusicUrl = 'https://ia800900.us.archive.org/26/items/music2_20250625/music2.mp3'; // Example mini-game music
        const miniGameJumpSfxUrl = 'https://ia801508.us.archive.org/17/items/jump_20250625/jump.mp3';
        const miniGameLandSfxUrl = 'https://ia801508.us.archive.org/17/items/land_20250625/land.mp3';
        const miniGameOverSfxUrl = 'https://ia801508.us.archive.org/17/items/gameover_20250625/gameover.mp3';

        function loadMiniGameAudio() {
            const loadSound = (url) => {
                return fetch(url)
                    .then(response => response.arrayBuffer())
                    .then(arrayBuffer => miniGameAudioListener.decodeAudioData(arrayBuffer));
            };

            Promise.all([
                loadSound(miniGameMusicUrl),
                loadSound(miniGameJumpSfxUrl),
                loadSound(miniGameLandSfxUrl),
                loadSound(miniGameOverSfxUrl)
            ]).then(([musicBuffer, jumpBuffer, landBuffer, gameOverBuffer]) => {
                miniGameBackgroundMusicBuffer = musicBuffer;
                miniGameJumpSoundBuffer = jumpBuffer;
                miniGameLandSoundBuffer = landBuffer;
                miniGameOverSoundBuffer = gameOverBuffer;

                // Wrapper function to play sounds
                miniGameSfx.play = (buffer, loop = false, volume = 1.0) => {
                    if (miniGameAudioListener.state === 'suspended') {
                        miniGameAudioListener.resume();
                    }
                    const source = miniGameAudioListener.createBufferSource();
                    source.buffer = buffer;
                    source.loop = loop;
                    const gainNode = miniGameAudioListener.createGain();
                    gainNode.gain.value = volume;
                    source.connect(gainNode);
                    gainNode.connect(miniGameAudioListener.destination);
                    source.start(0);
                    return { source, gainNode, isPlaying: true }; // Return source and gainNode for control
                };
                console.log("Mini-game audio loaded.");
            }).catch(e => {
                console.error("Error loading mini-game audio:", e);
                // Fallback for mini-game sfx if loading fails
                miniGameSfx.play = () => { return {isPlaying: false}; }; // Mute if audio fails
            });
        }
        loadMiniGameAudio();


        function playMiniGameMusic() {
            if (miniGameBackgroundMusicBuffer && miniGameAudioListener.state === 'suspended') {
                miniGameAudioListener.resume();
            }
            if (!miniGameMusicPlayer || !miniGameMusicPlayer.isPlaying) {
                if (miniGameBackgroundMusicBuffer) {
                    miniGameMusicPlayer = miniGameSfx.play(miniGameBackgroundMusicBuffer, true, 0.4);
                    console.log("Mini-game music started.");
                }
            } else if (miniGameMusicPlayer && miniGameAudioListener.state === 'running') {
                 // If already playing and context is running, do nothing, it's looping
            }
        }

        function stopMiniGameMusic() {
            if (miniGameMusicPlayer && miniGameMusicPlayer.source) {
                miniGameMusicPlayer.source.stop();
                miniGameMusicPlayer.isPlaying = false;
                miniGameMusicPlayer = null; // Clear the reference
                console.log("Mini-game music stopped.");
            }
        }

        function initMiniGame() {
            miniPlayer = {
                x: 50,
                y: MINI_GAME_HEIGHT - 30,
                width: 20,
                height: 20,
                dy: 0,
                gravity: 0.5,
                jumpStrength: -10,
                isJumping: false,
                grounded: true
            };
            obstacles = [];
            miniGameScore = 0;
            miniGameFrameCount = 0;
            miniGameScoreDisplay.textContent = `Score: ${miniGameScore}`;
            lastObstacleTime = 0; // Reset obstacle timer
            obstacleSpeed = 5; // Reset speed
            obstacleInterval = 2000; // Reset interval
        }

        function drawMiniGame() {
            miniGameCtx.clearRect(0, 0, MINI_GAME_WIDTH, MINI_GAME_HEIGHT);

            // Draw player
            miniGameCtx.fillStyle = 'blue';
            miniGameCtx.fillRect(miniPlayer.x, miniPlayer.y, miniPlayer.width, miniPlayer.height);

            // Draw obstacles
            miniGameCtx.fillStyle = 'red';
            obstacles.forEach(obstacle => {
                miniGameCtx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });

            // Draw ground
            miniGameCtx.fillStyle = 'green';
            miniGameCtx.fillRect(0, MINI_GAME_HEIGHT - 10, MINI_GAME_WIDTH, 10); // Simple ground line
        }

        function updateMiniGame(deltaTime) {
            miniPlayer.dy += miniPlayer.gravity;
            miniPlayer.y += miniPlayer.dy;

            // Ground collision
            if (miniPlayer.y >= MINI_GAME_HEIGHT - miniPlayer.height - 10) {
                if (!miniPlayer.grounded) {
                    if (miniGameLandSoundBuffer) miniGameSfx.play(miniGameLandSoundBuffer, false, 0.7);
                }
                miniPlayer.y = MINI_GAME_HEIGHT - miniPlayer.height - 10;
                miniPlayer.dy = 0;
                miniPlayer.isJumping = false;
                miniPlayer.grounded = true;
            } else {
                miniPlayer.grounded = false;
            }

            // Move obstacles
            obstacles.forEach(obstacle => {
                obstacle.x -= obstacleSpeed;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Generate new obstacles
            const currentTime = Date.now();
            if (currentTime - lastObstacleTime > obstacleInterval) {
                const lastObstacleX = obstacles.length > 0 ? obstacles[obstacles.length - 1].x : MINI_GAME_WIDTH;
                const nextObstacleX = lastObstacleX + Math.random() * (MINI_GAME_WIDTH / 2) + minObstacleGap;

                // Ensure it's not too close to the edge or previous obstacle
                if (nextObstacleX > MINI_GAME_WIDTH - 50 && nextObstacleX < MINI_GAME_WIDTH + 100) {
                    const obstacleWidth = Math.random() * 20 + 20;
                    const obstacleHeight = Math.random() * 30 + 20;
                    obstacles.push({
                        x: MINI_GAME_WIDTH, // Always start from right edge
                        y: MINI_GAME_HEIGHT - obstacleHeight - 10,
                        width: obstacleWidth,
                        height: obstacleHeight
                    });
                    lastObstacleTime = currentTime;
                    obstacleInterval = Math.max(800, obstacleInterval - 10); // Make it slightly faster over time
                    obstacleSpeed = Math.min(10, obstacleSpeed + 0.05); // Gradually increase speed
                }
            }

            // Collision detection
            obstacles.forEach(obstacle => {
                if (miniPlayer.x < obstacle.x + obstacle.width &&
                    miniPlayer.x + miniPlayer.width > obstacle.x &&
                    miniPlayer.y < obstacle.y + obstacle.height &&
                    miniPlayer.y + miniPlayer.height > obstacle.y) {
                    // Collision detected! Game Over
                    gameOverMiniGame();
                }
            });

            // Update score
            miniGameFrameCount++;
            if (miniGameFrameCount % 60 === 0) { // Update score every second (assuming 60fps)
                miniGameScore++;
                miniGameScoreDisplay.textContent = `Score: ${miniGameScore}`;
            }
        }

        let miniGameAnimationFrameId;
        function miniGameLoop(currentTime) {
            if (!miniGameActive) return;

            const deltaTime = (currentTime - (miniGameLoop.lastTime || currentTime)) / 1000;
            miniGameLoop.lastTime = currentTime;

            updateMiniGame(deltaTime);
            drawMiniGame();
            miniGameAnimationFrameId = requestAnimationFrame(miniGameLoop);
        }

        function startMiniGame() {
            mainMenu.style.opacity = 0;
            mainMenu.style.visibility = 'hidden';
            miniGameContainer.style.opacity = 1;
            miniGameContainer.style.visibility = 'visible';
            miniGameMobileControlsMenuButton.style.display = 'block'; // Show mini-game control toggle
            mobileControlsMenuButton.style.display = 'none'; // Hide main game control toggle
            gameRunning = false; // Ensure main game is not running
            miniGameActive = true;
            initMiniGame();
            playMiniGameMusic();
            miniGameLoop.lastTime = performance.now(); // Initialize lastTime for smooth delta
            miniGameAnimationFrameId = requestAnimationFrame(miniGameLoop);
            miniGameMobileControlsDiv.style.display = miniGameMobileControlsVisible ? 'flex' : 'none';
        }

        function gameOverMiniGame() {
            miniGameActive = false;
            cancelAnimationFrame(miniGameAnimationFrameId);
            stopMiniGameMusic();
            if (miniGameOverSoundBuffer) miniGameSfx.play(miniGameOverSoundBuffer, false, 0.8);
            showMessage(`Mini-Game Over! Your score: ${miniGameScore}`, false, '2D'); // Specify gameMode
            miniGameMobileControlsDiv.style.display = 'none'; // Hide controls on game over
            miniGameMobileControlsMenuButton.style.display = 'none'; // Hide control toggle on game over
        }

        miniGameButton.addEventListener('click', startMiniGame);

        backToMainMenuButton.addEventListener('click', () => {
            if (miniGameActive) {
                cancelAnimationFrame(miniGameAnimationFrameId); // Stop the mini-game loop
                miniGameActive = false;
            }
            stopMiniGameMusic();
            showMainMenu();
        });

        // --- Mini-Game Mobile Controls Logic ---
        const miniGameMobileControlsDiv = document.getElementById('mini-game-mobile-controls');
        const miniJumpButton = document.getElementById('mini-jump-button');
        const miniMobileControlsMenuButton = document.getElementById('miniGameMobileControlsMenuButton');

        const miniJoystickBase = document.getElementById('mini-joystick-base');
        const miniJoystickKnob = document.getElementById('mini-joystick-knob');

        let isMiniJoystickActive = false;
        let miniJoystickCenter = { x: 0, y: 0 };
        let miniMaxJoystickDistance = miniJoystickBase.offsetWidth / 2 - miniJoystickKnob.offsetWidth / 2;
        let currentMiniJoystickPos = { x: 0, y: 0 };

        function updateMiniJoystickBasePosition() {
            const rect = miniJoystickBase.getBoundingClientRect();
            miniJoystickCenter.x = rect.left + rect.width / 2;
            miniJoystickCenter.y = rect.top + rect.height / 2;
            miniMaxJoystickDistance = miniJoystickBase.offsetWidth / 2 - miniJoystickKnob.offsetWidth / 2;
            miniJoystickKnob.style.left = '50%';
            miniJoystickKnob.style.top = '50%';
            miniJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        // Event listeners for Mini-game joystick
        miniJoystickBase.addEventListener('touchstart', (e) => {
            if (!miniGameActive) return;
            e.preventDefault();
            isMiniJoystickActive = true;
            updateMiniJoystickBasePosition();
            const touch = e.touches[0];
            moveMiniJoystickKnob(touch.clientX, touch.clientY);
        }, { passive: false });

        miniJoystickBase.addEventListener('touchmove', (e) => {
            if (!isMiniJoystickActive || !miniGameActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            moveMiniJoystickKnob(touch.clientX, touch.clientY);
        }, { passive: false });

        miniJoystickBase.addEventListener('touchend', () => {
            isMiniJoystickActive = false;
            resetMiniJoystickKnob();
            currentMiniJoystickPos = { x: 0, y: 0 };
        });

        function moveMiniJoystickKnob(clientX, clientY) {
            let offsetX = clientX - miniJoystickCenter.x;
            let offsetY = clientY - miniJoystickCenter.y;

            const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);

            if (distance > miniMaxJoystickDistance) {
                offsetX = (offsetX / distance) * miniMaxJoystickDistance;
                offsetY = (offsetY / distance) * miniMaxJoystickDistance; // Corrected: was missing * miniMaxJoystickDistance
            }

            miniJoystickKnob.style.transform = `translate(${offsetX - miniJoystickKnob.offsetWidth / 2}px, ${offsetY - miniJoystickKnob.offsetHeight / 2}px)`;

            currentMiniJoystickPos.x = offsetX / miniMaxJoystickDistance;
            currentMiniJoystickPos.y = offsetY / miniMaxJoystickDistance;
        }

        function resetMiniJoystickKnob() {
            miniJoystickKnob.style.left = '50%';
            miniJoystickKnob.style.top = '50%';
            miniJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        let miniGameMobileControlsVisible = false;
        miniMobileControlsMenuButton.addEventListener('click', () => {
            miniGameMobileControlsVisible = !miniGameMobileControlsVisible;
            miniGameMobileControlsDiv.style.display = miniGameMobileControlsVisible ? 'flex' : 'none';
            if (miniGameMobileControlsVisible) {
                updateMiniJoystickBasePosition();
            }
        });

        miniJumpButton.addEventListener('touchstart', (e) => { // Use touchstart for mobile
            if (miniGameActive) {
                e.preventDefault();
                handleMobileJump('2D'); // Use the generalized jump handler
            }
        }, { passive: false });
        miniJumpButton.addEventListener('click', () => { // Keep click for desktop testing
            if (miniGameActive) {
                handleMobileJump('2D');
            }
        });


        // Add keyboard controls for mini-game (if needed, this will override mobile for testing on desktop)
        document.addEventListener('keydown', (e) => {
            if (miniGameActive) {
                if (e.code === 'Space' && !miniPlayer.isJumping && miniPlayer.grounded) {
                    handleMobileJump('2D'); // Use the generalized jump handler
                }
            } else if (gameRunning) { // Main game keyboard controls
                handleKeyDown(e);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameRunning) { // Main game keyboard controls
                handleKeyUp(e);
            }
        });


        // Initial setup
        showMainMenu(); // Show main menu on page load
    </script>
</body>
</html>
